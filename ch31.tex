\documentclass[twocolumn,oneside]{book}

\usepackage{refcheck}

\usepackage{epsf}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{science}
\usepackage{graphicx}
\bibliographystyle{handbook}

%\setlength{\textwidth}{86mm}
\setlength{\textwidth}{175.5mm}
\setlength{\textheight}{212mm}

\newenvironment{pbox}[1]{\begin{parbox}[t]{6.25cm}{#1\\}}{\end{parbox}}

\newcommand{\valpha}{\vector{\alpha}}
\newcommand{\vlambda}{\vector{\lambda}}
\newcommand{\vomega}{\vector{\omega}}
\newcommand{\vPhi}{\vector{\Phi}}
\newcommand{\vPsi}{\vector{\Psi}}
\newcommand{\btau}{\mbox{\boldmath$\tau$}}
\newcommand{\vtau}{\vector{\tau}}

\newcommand{\vzero}{\vector{0}}
\newcommand{\vone}{\vector{1}}
Corresponding points are represented by the tuple $(\V m_i,\V
d_i)$ where $\V m_i \in M \subset \hat M$ and $\V d_i \in D \subset
\hat D$. Two things have to be calculated: First, the corresponding
points, and second, the transformation ($\M R$, $\V t$) that minimizes
$E(\M R, \V t)$ on the basis of the corresponding points. The ICP
algorithm uses closest points as corresponding points. A sufficiently
good starting guess enables the ICP algorithm to converge to the
correct minimum. Fig.~\ref{fig:icp} shows two 3D point clouds, their
initial alignment and the final registration after a few ICP
iterations.
\begin{figure}
  \centering
\includegraphics[width=0.75\linewidth]{BOOKFIGS/start_1}\\
\includegraphics[width=0.75\linewidth]{BOOKFIGS/final_1}
\caption{Initial alignment of two 3D pint clouds (top) and after
  optimization with ICP (bottom).}\label{fig:icp}
\end{figure}  

Implementations of ICP (cf. algorithm~\ref{algo:ICP}) use a maximal
distance for closest points to handle partially overlapping point
sets. In this case, the proof about ICP's monotonic convergance
in~\cite{besl2} no longer holds, since the number of points as well as
the value of $E(\M R, \V t)$ might increase after applying a
transformation.

\begin{algorithm}
\caption{The ICP algorithm.}\label{algo:ICP}
\begin{algorithmic}[1]
\vspace*{2mm}
\FOR {$i = 0$ to \textit{maxIterations}}
  \FORALL {$\V d_j \in D$}
    \STATE {find the closest point within a range $d_\text{max}$ in the
      set $M$ for point $\V d_j$}
  \ENDFOR

  \STATE {Calculate transformation ($\M R, \V t$) that minimizes the
    error function Eq. (\ref{DMin})}

  \STATE  Apply the transformation found in step 5 to the data set
           $D$.

  \STATE Compute the difference of the quadratic error, i.e., compute the
  difference of the value $\norm{E_{i-1}(\M R, \V t) - E_i(\M R, \V t)}$
  before and after the application of the transformation. If this
  difference falls below a threshold
  $\varepsilon$, terminate.
\ENDFOR
\vspace*{2mm}
\end{algorithmic}
\end{algorithm}

Current research in the context of ICP algorithms mainly focuses on
fast variants of ICP algorithms~\cite{Rusi_2001}. If the input are 3D
meshes then a point-to-plane metric can be used instead of
Eq.~\eqref{DMin}. Minimizing using a point-to-plane metric outperforms
the standard point-to-point one, but requires the computation of
normals and meshes in a pre-processing step.

The computation of closest points is the crucial step of the ICP
algorithm. A naive implementation examines all points in $\hat M$ and
the resulting computation time for ICP is $O(|\hat D|\,|\hat M|)$,
i.e., $O(n^2)$. Note: $\hat N$ can be very large; advanced
high-precise 3D laser scanners such as the Zoller+Fr\"ohlich yield a
data rate up to 1.000.000 3D points per second. An efficient tree data
structure, a $k$-d tree, is widely used to speed-up the closest point
computation. Every node of the $k$-d tree represents a partition of
the point set into two distinct sets, the successor nodes. The root of
the tree represents the whole point set. The leaves of the tree are
called buckets and are a partition of the set into small, disjunctive
point sets. Furthermore, every node of the tree consists of the center
and the dimension of the point set.  In the original $k$-d tree paper,
these so-called split dimensions have been chosen depending of the
depth of node in a robin-round fashion~\cite{Bentley_1975}.  The split
dimension and value define an axis-aligned hyperplane in the
$k$-dimensional space. The data are partitioned according to their
position to the hyperplane into the successor nodes. The $k$-d tree is
constructed until the number of points in the nodes falls below a
threshold $b$ (bucket size). Only the leaves of the tree contain the
data points. Searching in $k$-d trees is done recursively. A given 3D
point $\V p_q$ needs to be compared to the separating plane (splitting
dimension and splitting value) in order to decide on which side the
search must continue. This procedure is executed until the leaves are
reached. There, the algorithm has to evaluate all bucket
points. However, the closest point may be in a different bucket, iff
the distance $d$ of the query point $\V p_q$ to the limits is smaller
than the one to the closest point in the bucket $\V p_b$.  In this
case backtracking has to be performed. The test is known as
Ball-Within-Bounds test~\cite{Bentley_1975, Friedman_1977,
  Greenspan_2003}. The optimized $k$-d tree choses the split dimension
and split value~\cite{Friedman_1977}, such that the expected amount of
backtracking is minimized.  Since one typically has no information
about the query points $k$-d tree algorithms take only the
distribution of the given points into account. For all possible
queries this works sufficiently, but it will not be optimal for a
specific query~\cite{Friedman_1977}. This enables the recursive
construction and avoids the overall optimization that is known to be
NP-complete~\cite{Hyafil_1977}.

Improvements to $k$-d tree search, especially for small dimensions,
have been presented in the last decade. They include approximate $k$-d
tree search~\cite{Greenspan_2003}, registration using
$d$2-trees~\cite{Mitra_2004} and cached $k$-d tree search
\cite{3DIM_2007}. In addition, the spatial data structure oc-tree
might, which is discussed later in this section, can used to search
the point clouds with similar performance.

In each ICP iteration, the transformation can be calculated in $O(N)$
by any of these four methods: (1) a singular value decomposition (SVD)
based method by Arun et al.~\cite{arun}, (2) a quaternion based
method by Horn~\cite{Horn_1988}, (3) an algorithm using orthonormal
matrices by Horn et al.~\cite{Horn_1987}, and (4) a calculation based
on dual quaternions by Walker et al.~\cite{Walker_1991}. Besides these
closed-form solutions, there are several linearized, approximative
version~\cite{CVIU2010}. The challenge is to ensure thar $\M R$ is
orthonormal. Most often, the first method is implemented, due to it's
simplicity and the availability of numerical SVDs in various
libraries. The rotation $\M R$ is represented as an orthonormal $3
\times 3$ matrix.  The optimal rotation is calculated by $\M R = \M V
\M U^T$. Here the matrices $\M V$ and $\M U$ are derived by the SVD
$\M H = \M U \M \Lambda \M V^T$ of a cross correlation matrix $\M
H$. This $3 \times 3$ matrix $\M H$ is given by
\begin{align}
\M H =  \sum_{i=1}^{N} \V m'^T_i \V d'_i 
 =  \begin{pmatrix}
S_{xx} & S_{xy} & S_{xz} \\
S_{yx} & S_{yy} & S_{yz} \\
S_{zx} & S_{zy} & S_{zz} \\
\end{pmatrix}, \label{korrelation} 
\end{align}
where $S_{xx} = \sum_{i=1}^{N} \ m'_{x,i} d'_{x,i}, \ S_{xy} =
\sum_{i=1}^{N} \ m'_{x,i} d'_{y,i}, \ \ldots \, $.

\subsection{Marker and Feature-based Registration} 

To avoid issues with starting guess in the ICP framework, marker based
registration uses defined artificial or natural landmarks as
corresponding points. This manual data association ensures that by
minimizing Eq.~\eqref{DMin} the scans are registered at the correct
location. Iterations are no longer required, but possible a
verification with the RANSAC algorithm. The RANSAC algorithm is a
general, randomized procedure that iteratively finds an accurate model
for observed data that may contain a large number of
outliers~\cite{ransac}.

\subsubsection{3D Feature Representations and Extraction}\label{3d_feature_extraction.ch31}

There are many representations available for encoding 3D scene
structure and model representations, but the following representations
are the ones most commonly encountered in robotics applications. Some
scene models or descriptions may use more than one of these
simultaneously to describe different aspects of the scene or object
models.

\begin{itemize}

\item {\bf Normals \index{Normal}}:

  Normals describe the surface orientation in a points. There are a
  number of approaches that have been developed for computing normals
  in point clouds and range images. Most of these approaches involves
  some form of eigenvalue decomposition resembling total linear least
  squares. The normals are usually computed when taking into account
  the nearby neighbor points which are computed using a variety of
  meth- ods like Nearest Neighbor Search. These methods include $k$
  Nearest Neighbors ($k$NN) and radius search among others. The method
  of total least squares is robust to noise as it inherently includes
  low pass filtering but it sensitive to the distribution and density
  of the point samples as well as the curvature of the underlying
  manifold. Improvements to the above method by using higher order
  surfaces are discussed in~\cite{Mitra_2003} and it is noted that
  such methods can fail even with arbitrarily dense samples.

  The total least squares problem is finding the plane parameters
  that optimally fit a small surface area in a point set given by the 
  the nearest neighbors. A plane is defined by the equation
\begin{align*}
  n_x x + n_y y + n_z z - d = 0
\end{align*}  
  where $\V p = (x, y, z)^T$ lies on the plane and $(n_x, n_y, n_z,
  d)$ are the parameters to compute. Given a subset of $k$ 3D points
  $p_i, i = 1, 2, \ldots, k$ of the surface, least squares finds the
  optimal normal vector $n = (n_x, n_y, n_z )^T$ and scalar $d$ that
  minimizes the following error equation
\begin{align}
  e = \sum_{i=1}^k (\V p_i \V n - d)\label{eq:normal}
\end{align}  
  The basic method for normal estimation from the neighboring points
  using a fitting a plane is the Principal Component Analysis (PCA).
  PCA is the eigenvalue decomposition of the data covariance (or
  correlation) matrix or singular value decomposition of a data
  matrix, usually after mean centering (and normalizing) the data
  matrix for each attribute (3D query point). PCA can be interpreted
  as fiting a Gaussian distribution and computing the main axes. For
  each query point
\begin{align*}
  \V \mu    & = \frac{1}{k} \sum_{i=1}^{k} \V p_i \\
  \M \Sigma & = \frac{1}{k} \sum_{i=1}^{k} (\V p_i - \V \mu)^T(\V p_i - \V \mu)
\end{align*}
  The vector corresponding to the smallest eigenvalue of the above
  matrix $\M \Sigma$ is the normal direction if the neighboring
  points belong to a plane and this is also the closed form
  solution of the total least squares problem.

  For equirectangular range images, i.e., spherical coordinates, a
  fast algorithm has been developed in~\cite{Badino_2011} that avoids
  computing eigenvalues. Dividing \eqref{eq:normal} by $d^2$ gives a
  simplified function and further division by the squared range
  $\rho^2$ yields
\begin{align*}
  e = \sum_{i=1}^k \left( (\rho^{-1}\V p_i)^T \V n - \rho_i^{-1}\right)^2
  \qquad
  \V p_i =
  \begin{pmatrix}
    \cos \theta_i \sin \phi_i\\
    \sin \theta_i \sin \phi_i\\
    \cos \phi_i
  \end{pmatrix}
\end{align*}  
  Therefore, a solution for $\V n$ is given as:
\begin{align*}
  \V n = \M M^{-1} \V b \quad \text{where} \ \M M = \sum_{i=1}^{k}\V p_i \V p_i^T,
  \V b = \sum_{i=1}^{k} \frac{\V p_i}{\rho_i}.
\end{align*}
  This way the computation of eigenvalues is avoided and the matrix
  $\M M$ can be precomputed for the desired image coordinates as it
  does not depend on the range. The tangential surface and therefore
  its normal vector is obtained by simply taking the derivative of
  the surface function in the point of interest.
\begin{align*}
  \V n
  & = \nabla \rho = \nabla \rho(\theta,\phi)\\
  & = \begin{pmatrix}
    \cos \theta \sin \theta
    - \frac{\sin \theta}{\rho \sin \phi} \frac{\partial \rho}{\partial \theta}
    + \frac{\cos \theta \cos \phi}{\rho} \frac{\partial \rho}{\partial \phi}\\
    \sin \theta \sin \theta
    - \frac{\cos \theta}{\rho \sin \phi} \frac{\partial \rho}{\partial \theta}
    + \frac{\sin \theta \cos \phi}{\rho} \frac{\partial \rho}{\partial \phi}\\
    \cos \phi - \frac{\sin \phi}{\rho} \frac{\partial \rho}{\partial \phi}
    \end{pmatrix}
\end{align*}

  
\item {\bf 3D Point Features \index{Point Features}}:

  This is a set $\{ \V p_i = (x_i,y_i,z_i)\}$ of 3D points that
  describe some salient and identifiable points in the scene. They
  might be the centers of spheres (often used as markers), corners
  where 3 planes intersect, or the extrema of some protrusion or
  indentation on a surface.  They may be a subset of an initially
  acquired 3D full scene point set, or they might be extracted from a
  range image, or they might be computed theoretical points based on
  extracted data features.

  An early example of 3D Point features and descriptors are Spin Images,
  which are used for surface matching between point clouds and meshes.
  Scanned 3-D points become the vertices of the mesh and connectivity
  is established by the 3-D scanning geometry. A fundamental component
  of the surface matching representation is an oriented point, a
  three-dimensional point with an associated direction.  Huber et
  al. define an oriented point $\V O$ at a surface mesh vertex using
  the 3-D position of the vertex $\V p$ and the surface normal at the
  vertex $\V n$~\cite{HuberPhD}.  Two coordinates can be calculated
  given an oriented point: $\alpha$ the radial distance to the surface
  normal line $L$ and $\beta$ the axial distance above the tangent
  plane $P$ (cf.~Figure~\ref{fig:spinimage}).
  \begin{align*}
    \begin{array}{l}
  (\V x) \mapsto (\alpha, \beta) = \\[1.1ex]
    (\sqrt{||\V x - \V p||^2 - ( \V n \cdot (\V x -\V p))^2},
      \V n \cdot (\V x - \V p))
      \end{array}
  \end{align*}
  \begin{figure}
    \centering
    \includegraphics[width=0.75\linewidth]{BOOKFIGS/spinimage}
    \caption{Definition of a spin image.}\label{fig:spinimage}
  \end{figure}

  The term spin-map originates from the cylindrical symmetry of the
  oriented point basis; the basis can spin about its axis with no
  effect on the coordinates of points with respect to the
  basis~\cite{HuberPhD}. A consequence of the cylindrical symmetry is
  that points that lie on a circle that is parallel to $P$ and centered
  on $L$ will have the same coordinates $(\alpha,\beta)$ with respect
  to the basis.
 
  Seminal work on 3D point features are the Point Feature Histograms
  (PFH) descriptors. They encode a point's $k$-neighborhood geometrical
  properties by generalizing the mean curvature around the point using
  a multi-dimensional histogram of values~\cite{RaduPhD}. This highly
  dimensional hyperspace aims at providing an informative signature
  for the feature representation, aims at being invariant to the 6D
  pose of the underlying surface, and aims at coping very well with
  different sampling densities or noise levels present in the
  neighborhood~\cite{pointclouds.org}.

  To formulate the new feature space, the concept of a dual-ring
  neighborhood is first introduced.  Following the notation and the
  text of~\cite{RaduPhD} let $P$ be a set of 3D points with $x_i, y_i,
  z_i$ the geometric coordinates. A point $\V p_i$ of $P$ is said to
  have a dual-ring neighborhood if:
  \begin{align*}
  r_1, r_2 \in R \ r_1 < r_2 \
  \text{, such that}
  \left\{
  \begin{array}{l}
    r_1 \to P^{k_1}\\
    r_2 \to P^{k_2}
  \end{array}
  \right.
  \end{align*}
  with $0 < k_1 < k_2$. The two radii $r_1$ and $r_2$ are used to
  determine two distinct layers of feature representations for $\V
  p_i$. The first layer represents the surface normal at the query
  point from the neighborhood patch $P^{k_1}$. The second layer
  comprises the Point Feature Histogram as a set of angular features
  (cf. Fig.~\ref{fig:angular_feature}):
  \begin{align*}
    \alpha & = \V v \cdot \V n_t \\
    \phi   & = \V u \cdot \frac{(\V p_t - \V p_s)}{d}\\
    \theta & = \arctan(\V w \cdot \V n_t, \V u \cdot \V n_t)
  \end{align*}
  \begin{figure}
    \centering
    \includegraphics[width=0.85\linewidth]{BOOKFIGS/angular_feature}
    \includegraphics[width=0.6\linewidth]{BOOKFIGS/pfh}
    \caption{Angular features in PFHs (top) and the definition of the
      two regions (bottom).}\label{fig:angular_feature}
  \end{figure}  

  In addition to 3D structural features, 3D features derived from
  texture, e.g., co-registered color images or scan reflectivities,
  are widely used for registration~\cite{Boehm_2007,rgbdslam}.
  Fig.~\ref{fig:scansift} shows SIFT features extracted from a 3D
  scanner with calibrated reflectivity values.
  \begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{BOOKFIGS/scansift}
    \caption{Sift features extracted from the reflectivity values of a
      3D laser scan.}\label{fig:scansift}
  \end{figure}  
  
\item {\bf Planes}:
  
  A planar surface may only be described by the infinite surface as
  given by the equation, but it may also include a description of the
  boundary of the surface patch. Convenient representations for
  robotics applications are lists of the 3D points $\{(x_i,y_i,z_i)\}$
  that form the patch boundary, or polylines, which represent the
  boundary by a set of connected line segments. A polyline is
  represented by the sequence of 3D points $\{(x_i,y_i,z_i)\}$ that
  form the vertices that join the line segments.

  Plane extraction, or plane fitting, is the problem of modeling a
  given 3D point cloud as a set of planes that ideally explain every
  data point. The RANSAC algorithm is one possible algorithm. When
  adapted for plane finding, this algorithm selects three 3D points at
  random (although exploiting some locality to the point selection
  algorithm can improve the efficiency of the algorithm). These three
  points determine a plane with parameter vector ${\bf \it a}$.  Test
  all points $\{ \V p \}$ in the set for belonging to the plane
  ({\it i.e.} $\mid \V p_i \cdot \V a \mid < \tau$).  If
  enough points are close to the plane, then potentially a plane has
  been found.  These points should also be processed to find a
  connected set, from which a more accurate set of plane parameters
  can be estimated using the least-square algorithm given above.  If a
  planar patch is successfully found, the points that lie in that
  plane are removed from the dataset.  The random selection of three
  points then continues until no more planes are found (a bound on how
  many tries to make can be estimated). For example Schnabel et
  al.~\cite{Schnabel:2007} have adapted RANSAC for plane extraction
  and found that the algorithm performs precise and fast plane
  extraction, but only if the parameters have been fine-tuned
  properly. For their optimization they use knowledge, that is not
  readily available in point cloud data, such as normals, neighboring
  relations and outlier ratios.

  A further standard method for plane detection is region growing,
  based on a seed patch. When the scene largely consists of planes, a
  particularly simple approach is based on selecting a previously
  unused point and the set of points $\{\V p_i = (x_i,y_i,z_i)\}$ in
  its neighborhood. A plane is fit to these points using the least
  square method (cf. normal computation).  This hypothesized plane
  then needs to be tested for reasonableness by 1) examining the
  smallest eigenvalue - it should be small and on the order of the
  square of the expected noise level and 2) ensuring that most of the
  3D points in the fitted set lie on the plane ({\it i.e.} $\mid
  {\V p}_i \cdot \V a \mid < \tau$).

  Larger planar regions are ``grown'' by locating new adjacent points
  $\V p_i$ that lie on the plane ({\it i.e.} $\mid \V p_i \cdot \V a
  \mid < \tau$).  When enough of these are found, the parameters $\V
  a$ of the plane are re-estimated.  Points on the detected plane
  are removed and the process is repeated with a new seed patch.
  This process continues until no more points can be added.
  complete descriptions of planar feature extraction with region
  growing is given in~\cite{hoover}.

  Bauer et al. use the radon transform to detect planes in volume
  data~\cite{Bauer:2008}. The idea and the speed of the algorithm are
  similar to that of the Standard Hough Transform. The Hough
  Transform~\cite{Hough:1962} is a method for detecting parametrized
  objects. For the Hough transform planes are represented in the Hesse
  normal form, using normal vectors. A plane is thereby given by a
  point $\V{p}$ on the plane, the normal vector $\V{n}$ that is
  perpendicular to the plane and the distance $\rho$ to the origin
  \begin{align*}
    \rho = \V p \cdot \V n  = {p}_x {n}_x + {p}_y {n}_y + {p}_z {n}_z = \rho .
  \end{align*}
  Considering the angles between the normal vector and the coordinate
  system, the coordinates of $\V n$ are factorized to
  \begin{align}
    {p}_x \cdot \cos{\theta} \cdot \sin{\varphi} + {p}_y \cdot \sin{\varphi} \cdot \sin{\theta} + {p}_z \cdot \cos{\varphi} = \rho ,
    \label{eq:polar}
  \end{align}
  with $\theta$ the angle of the normal vector on the $xy$-plane and
  $\varphi$ the angle between the $xy$-plane and the normal vector in
  $z$ direction. $\varphi$, $\theta$ and $\rho$ define the
  3-dimensional Hough Space ($\theta,\varphi,\rho$) such that each
  point in the Hough Space corresponds to \emph{one plane} in
  $\mathbb{R}^3$. To find planes in a point set, one calculates the
  Hough Transform for each point. Given a point $\V p$ in Cartesian
  coordinates, one finds all planes the point lies on, i.e., find all
  the $\theta$, $\phi$ and $\rho$ that satisfy Eq.~\eqref{eq:polar}
  Marking these points in the Hough Space, i.e., leads to a 3D
  sinusoid curve as shown in Fig.~\ref{fig:houghcurve}. The
  intersections of two curves in Hough Space denote the planes that
  are rotated around the line built by the two points. Consequently,
  the intersection of three curves in Hough Space corresponds to the
  polar coordinates defining the plane spanned by the three points. In
  Fig.~\ref{fig:houghcurve} the intersection is marked in black.
  %
  Given a set $P$ of points in Cartesian coordinates, one transforms
  all points $\V{p}_i \in P$ into Hough Space. The more curves
  intersect in $\V{h}_j \in (\theta, \varphi, \rho)$, the more points
  lie on the plane represented by $\V{h}_j$ and the higher is the
  probability that $\V{h}_j$ is actually extracted from $P$.
  %
  \begin{figure}
    %\psfrag{phi}{$\varphi$}
    %\psfrag{theta}{$\theta$}
    %
    \includegraphics[width=0.4\textwidth]{BOOKFIGS/Hough}
    \caption{Transformation of three points from $R$ to % FIXME mathbbm R
      Hough space ($\theta,\varphi,\rho$). The intersection of the
      curves (marked in black) depicts the plane spanned by the three
      points.}
    \label{fig:houghcurve}
  \end{figure}
  %  

  The Standard Hough Transform is far too slow for plane detection in
  real world data. A variant called Randomized Hough Transform is the
  method of choice when dealing with 3D data due to its exceptional
  performance as far as runtime and quality is
  concerned~\cite{Borrmann_2011}.
  
  Other plane extraction algorithms are highly
  specialized for a specific application and are not in widespread use
  for miscellaneous reasons. Lakaemper et al.~\cite{Lakaemper:2006}
  use an Expectation Maximization (EM) algorithm to fit planes that
  are initially randomly generated, Wulf et al.~\cite{Wulf:2004}
  detect planes relying on the specific properties of a sweeping laser
  scanner and Yu et al.~\cite{Yu:2008} developed a clustering approach
  to solve the problem.  

\item {\bf Triangulated Surfaces \index{Triangulated Surfaces}}:

  Most commonly, surfaces are approximated by polygonal meshes,
  particularly triangle meshes, a standard data structure in computer
  graphics to represent 3D objects. This representation describes an
  object or scene by a set of triangular patches. More general
  polygonal surface patches or even various smooth surface
  representations are also used, but triangles are most commonly used
  because they are simpler and there are inexpensive PC graphics cards
  that display triangles at high speed.

  The triangles can be large ({\it e.g.} when representing planar
  surfaces) or small ({\it e.g.} when representing curved surfaces).
  The size chosen for the triangles reflects the accuracy desired for
  representing the object or scene surfaces.  The triangulated surface
  might be complete in the sense that all observable scene or objects
  surfaces are represented by triangles, or there might be
  disconnected surface patches with or without internal holes.  For
  grasping or navigation, you don't want any unrepresented scene
  surface to lie in front of the represented portion of the surface
  where a gripper or vehicle might collide with it.  Hence, we assume
  that the triangulation algorithms produce patch sets that, if
  completely connected at the edges, implicitly bound all real scene
  surfaces. Figure~\ref{timmesh} shows an example of a triangulated
  surface and the original point cloud.
\begin{figure}
    \includegraphics[width=0.5\textwidth]{BOOKFIGS/kinect_fusion}
\caption{Left: image acquired with a kinect-like sensor.
  Right: Reconstruction with kinect fusion. \label{timmesh}}
\end{figure}

  The de-facto standard is the Marching Cubes method introduced by
  Lorensen et al. \cite{lorensen87marching}. This algorithm
  sub-divides the scanned volume into cubic cells or voxels. For each
  cell the intersections between the cell edges and the surface are
  calculated. Pre-calculated surface patterns are then used to
  generate a local triangle mesh approximation. An example of such
  patterns are given in Fig.~\ref{fig:patterns}. To interpolate the
  intersections, implicit continuous surface representations like
  planes or splines are fitted to the local data using least squares
  fits~\cite{alexa02computing,hoppe}.
  %
  % FIXME More about Hoopes distance function
  %
  A feature of the Marching Cubes algorithm is that it produces more
  triangles than are needed to represent an object.  Hence, several
  mesh simplification algorithms have been introduced over the past
  years. Most of them define error metrics that indicate the error
  that a certain operation causes to the model, i.e., the removal of
  an edge~\cite{melax98simple, garland97surface}. To optimize the
  model, the edges causing minimal error to the topology are removed
  iteratively. Since after each edge removal new vertices have to be
  inserted into the mesh, the initial topology can be altered.
\begin{figure}
    \includegraphics[width=0.5\textwidth]{BOOKFIGS/marching_cube_patterns}
\caption{Pattern for meshing 3D voxels. 256 combinations are possible,
  but it is sufficient to model 16, iff symmetries are considered.
\label{fig:patterns}}
\end{figure}

  The kinect fusion approach modifies Hoppe's distance
  function~\cite{kinectfusion}. It exploits the properties of the
  depth image (rectangular) to calculate normals and the associated
  planes. The method is massively parallelized by a GPU implementation
  and can reconstruct and register meshes in real-time.

\item {\bf 3D lines}:
  
  The 3D lines where planar surfaces meet are features that can be
  easily detected by both stereo and range sensors.  These features
  occur commonly in built environments ({\it e.g.} where walls,
  floors, ceilings and doorways meet, around the edges of wall
  structures like notice boards, at the edges of office and warehouse
  furniture, etc.).  They are also common on manmade objects.  In the
  case of stereo, changes of surface shape or coloring are detected as
  edges, which can be matched in the stereo process to directly
  produce the 3D edge.  In the case of a range sensor, planar surfaces
  can be easily extracted from the range data (see next section) and
  adjacent planar surfaces can be intersected to give the edges.

  The most straightforward representation for 3D lines is the set of
  points $\V x = \V p + \lambda \V v$ for all $\lambda$, where $\V v$
  is a unit vector.  This has 5 degrees of freedom; more complex
  representations {\it e.g.} with 4 degrees of freedom exist
  \cite{hartley}.

\item {\bf Voxels}

  The \index{voxel} voxel (volume pixel) approach represents the 3D
  world by 3D boxes/cells that indicate where there is scene structure
  and where there is free space.  The simplest representation is a 3D
  binary array, encoded as 1 for having structure and 0 for free
  space.  This can be quite memory intensive, and also requires a lot
  of computation to check many voxels for content.  A more complex but
  more compact representation is the hierarchical representation
  called the octree \cite{foley}. This divides the entire (bounded)
  rectangular space into 8 rectangular subspaces called octants (see
  Figure \ref{octree}).  A tree data structure encodes the content of
  each octant as empty, full or mixed.  Mixed octants are then
  subdivided into 8 smaller rectangular octants, encoded as subtrees
  of the larger tree.  Subdivision continues until some minimum octant
  size is reached.  Determining whether a voxel is empty, full or
  mixed depends on the sensor used, however, if no 3D data points are
  located in the volume of a voxel, then it is likely to be empty.
  Similarly, if many 3D points are present, then the voxel is likely
  to be full. Currently, many implementations using octrees for range
  data are available~\cite{ISPRS2013,Hornung_2013}. Furthermore, these
  voxel representations are the basis of surface/mesh reconstruction
  algorithms as describes earlier.
\begin{figure}
    \includegraphics[width=0.4\textwidth]{BOOKFIGS/octree}
\caption{Top: Spatial subdivisions of an octree up to level
  3. Occupied leaf nodes are shaded grey.  Bottom: The corresponding
  tree structure of the sparse data structure. 
\label{octree}}
\end{figure}

  For the purpose of robot navigation, localization or grasping, only
  the surface and \index{free space voxels} free space voxels need to
  be marked accurately. The interior of objects and scene structure
  are largely irrelevant.

\item {\bf Straight lines}: 

  While straight lines are common in man-made scenes, direct
  extraction from 3D datasets is not easy.  The main source of the
  difficulty is 3D sensors often do not acquire good responses at
  edges of surfaces.
% -> Modern FWA scanners can do this!!!
% 1) the sensor beam will be sampling from two different surfaces and
% 2) laser based sensors produce somewhat unpredictable effects.
%
  For this reason, most 3D line detection algorithms are indirect,
  whereby planes are first detected, {\it e.g.} using the method of
  the previous section, and then adjacent planes are intersected.
  Adjacency can be tested by finding paths of connected pixels that
  lead from one plane to the other.
%
  If planes 1 and 2 contains points $\V p_1$ and $\V p_2$ and have
  surface normals $\V n_1$ and $\V n_2$ respectively, then the
  resulting intersection line has equation $\V x = \V a + \lambda \V
  d$ where $\V a$ is a point on the line and $\V d = \frac{\V n_1
    \times \V n_2} {\mid\mid \V n_1 \times \V n_2 \mid\mid}$ is the
  line direction.

  There are an infinite number of possible points $\V a$, which can be
  found by solving the equations $\V a' \V n_1 = \V p_1' \V n_1$ and
  $\V a' \V n_2 = \V p_2'\V n_2$. A reasonable third constraint that
  obtains a point near to $\V p_2$ is the equation $\V a' \V d = \V
  p_2' \V d$. This gives us an infinite line. Most practical
  applications require a finite segment. The endpoints can be
  estimated by 1) finding the points on the line that lie close to
  observed points in both planes and then 2) finding the two extremes
  of those points.  On the other hand, finding straight 3D lines can
  be easier with a stereo sensor, as these result from matching 2
  straight 2D image lines.

\end{itemize}

\subsection{Multiple-View Registration\label{match31}}\index{Multiple-View Registration}

A globally consistent representation of a robot's environment is
crucial for many robotic applications. Equipped with a 3D
depth-perceiving sensor, many mobile systems gather spatial
information about their local 3D environments. Any iterative
application of matching algorithms leads to inconsistencies due to
sensing errors and to the inaccuracies in the matching procedures
itself. To avoid these problems, global matching algorithms are
needed, taking global correspondences between range sensor data into
account. Simultaneous localization and mapping (SLAM) algorithms as
discussed in chapter \ref{FIXME} solve a very similar problem. In
addition to registering multiple views, they estimate a map.
Multiple-View Registration also relates to Bundle adjustment in the
photogrammetry community and structure from motion (SFM).

If $n$-views have to be registered, any sequential application of a
two point--set registration method will accumulate errors, and
therefore the registration algorithm (cf. section~\ref{sec:icp6D}) has
to be extended. The global error function becomes
\begin{align}
E & =  \sum_{l \to k} \sum_{i} \norm{(\M R_l \V m_{l,i} + \V t_l) - (\M R_k \V d_{k,i}
 + \V t_k)}^2, \label{DMinGlobal}
\end{align}
where all views have their unique pose $(\M R, \V t)$. After the point
pairs for all overlapping views $(l,k)$ have been found,
Eq.~\eqref{DMinGlobal} is minimized. Unfortunately, a closed-form
solution for minimizing Eq.~\eqref{DMinGlobal} is not know, but a
small angle approximation or the helix transform yield a system of
linear equations that can be solved by Choleskey
decomposition~\cite{CVIU2010}. In an ICP-like fashion after every
transformation new point pairs have to be found
(cf. algorithm~\ref{algo:gICP}).
%
\begin{algorithm}
\caption{The globally consistent ICP algorithm.}\label{algo:gICP}
\begin{algorithmic}[1]
\vspace*{2mm}
\FOR {$i = 0$ to \textit{maxIterations}}
   \STATE {find the closest point within a range $d_\text{max}$ of
      every pair of overlapping 3D point clouds $(l,k)$.}
 
  \STATE {Calculate $n$ transformations ($\M R, \V t$) simultaneously
    that minimize the error function Eq. (\ref{DMinGlobal})}

  \STATE  Apply the $n$ transformations found in step 4 to all data sets.

  \STATE Compute the difference of the quadratic error, i.e., compute
  the difference of the value $\norm{E_{i-1} - E_i}$ before and after
  the application of the transformation. If this difference falls
  below a threshold $\varepsilon$, terminate.  \ENDFOR
\vspace*{2mm}
\end{algorithmic}
\end{algorithm}
%

A probabilistic SLAM-like notation of Eq.~\eqref{DMinGlobal} was
formulated in~\cite{lu97} for 2D range scans. For each pose ${\V X}$,
the term $\bar{\V X}$ denotes a pose estimate, and $\Delta {\V X}$ is
the pose error. The positional error of two poses ${\V X}_j$ and
${\V X}_k$ is described by:
\begin{align*}
E_{j,k} &= \sum^m_{i=1} \norm{ {\V X}_j \oplus {\V d}_i - {\V X}_k \oplus
{\V m}_i }^2 
\end{align*}
Here, $\oplus$ is the compounding operation that transforms a point
into the global coordinate system.  For small pose differences,
$E_{j,k}$ can be linearized by use of a Taylor expansion. With the
linearized error metric ${\V E}'_{j,k}$ and the Gaussian distribution
$(\bar{\V E}_{j,k}, {\M C}_{j,k})$ a Mahalanobis distance that
describes the global error of all the poses is constructed
\begin{align}
{\M W} &= \sum_{j \rightarrow k} (\bar{\V E}_{j,k} - {\V E}'_{j,k})^{T} {\M C}^{-1}_{j,k}
(\bar{\V E}'_{j,k} - {\V E}'_{j,k}) \nonumber \\
&=  \sum_{j \rightarrow k}
\bigl(\bar{\V E}_{j,k} - ({\V X}'_j - {\V X}'_k)\bigr)
{\M C}^{-1}_{j,k} \bigl(\bar{\V E}'_{j,k} - ({\V X}'_j - {\V X}'_k)\bigr),\label{eq:u1}
\end{align}
which can be solved efficiently using iterative least squares
techniques, e.g., Levenberg-Marquadt or conjugate gradient methods
\cite{konolige04,kelly03}.  The covariances are computed from point
pairs. In the presence of correct covariances, Eq.~\eqref{eq:u1} is
minimized once. In case of scan matching, new pose estimates yield new
closest point pairs and in turn new covariances. Iterating the process
of calculating point pairs and minimization yields a stable algorithm
that converges rapidly. The probabilisty notation and the global ICP
notation are very similar~\cite{CVIU2010}. The solution for 2D range
scans has been extended to to 6DoF in~\cite{RAS2007}.

\subsection{Model Matching}

Model matching is the process of matching some stored representation
to some observed data. In the case discussed here, we assume that both
are 3D representations.  Furthermore, we assume that the
representations being matched are both of the same type, {\it e.g.} 3D
model and scene lines. (While different types of data can also be
matched, we ignore these more specialized algorithms here.)

A special case of matching is when the two structures being matched
are both scene or model surfaces. The algorithm used for matching
depends on the complexity the structures being matched.  If the
structures being matched are extended geometric entities such as
planes or 3D lines, then a discrete matching algorithm like the
Interpretation Tree algorithm \cite{grimson} can be used. It is
suitable for matching small numbers ({\it e.g.} less than about 20-30)
discrete objects, such as vertical edges seen in 2D or 3D. If there
are $M$ model and $D$ data objects, then potentially there are $M^D$
different matches. The key to efficient matching is to identify
pairwise constraints that eliminate unsuitable matches. Constraints
between pairs of model features and pairs of data features also
greatly reduce the matching space. If the constraints eliminate enough
features, a polynomial time algorithm results.  The core of the
algorithm is defined as follows.  Let $\{m_i\}$ and $\{d_j\}$ be the
sets po model and data features to be matched, $u(m_i,d_j)$ is true if
$m_i$ and $d_j$ are compatible features, $b(m_i,m_j,d_k,d_l)$ is true
if the four model and data features are compatible and $T$ is the
minimum number of matched features before a successful match is
declared.  \verb+Pairs+ is the set of successfully matched features.
The function \verb+truesizeof+ counts the number of actual matches in
the set, disregarding matches with the wildcard * which matches
anything.
%!!! get algorithm on 1 page !!!
\begin{verbatim}
pairs=it(0,{})
if truesizeof(pairs) >= T, then success

function pairs=it(level,inpairs)
  if level >= T, then return inpairs
  if M-level+truesizeof(inpairs) < T
    then return {} % can never succeed
  for each d_i % loopD start
    if not u(m_level,d_i), then continue loopD
    for each (m_k,d_l) in inpairs
      if not b(m_level,m_k,d_i,d_l)
        then continue loopD
    endfor
    % have found a successful new pair to add
    pairs = it(level+1,
                 union(inpairs,(m_level,d_i)))
    if truesizeof(pairs) >= T, then return
  endfor % loopD end

  % no success, so try wildcard  
  it(level+1,union(inpairs,(m_level,*)))
\end{verbatim}

\subsection{Relative Pose Estimation\label{pose23}} \index{Pose Estimation}

Central to many tasks is the estimation of the coordinate system
relative position or pose transformation between two coordinate
systems.  For example, this might be the pose of a scanner mounted on
a mobile vehicle relative to scene landmarks.  Or, it might be the
relative pose of some scene features as observed in two views taken
from different positions.

We present here three algorithms that cover most instances of the pose
estimation process, which differ slightly based on the type of feature
being matched.

\ \\
\noindent
{\bf Point set relative pose estimation}

The ICP algorithm can be used relative pose estimation as well
(cf.~\ref{sec:icp6D}).

\ \\
\noindent
{\bf Straight line relative pose estimation}

If 3D lines are the features that are extracted, then the relative
pose transformation can be estimated as follows.  Assume $N$ paired
lines.  The first set of lines is described by direction vectors $\{\V
e_i\}$ and a point on each line $\{\V a_i\}$.  The second set of lines
is described by direction vectors $\{\V f_i\}$ and a point on each
line $\{\V b_i\}$.  In this algorithm, we assume that the direction
vectors on the matched segments always point the same direction ({\it
  i.e.} are not inverted). This can be achieved by exploiting some
scene constraints, or trying all combinations and eliminating
inconsistent solutions. The points $\V a_i$ and $\V b_i$ need not
correspond to the same point after alignment. The desired rotation
matrix $\M R$ minimizes $\sum_i \mid\mid \M R \V e_i - \V f_i
\mid\mid^2$.  Construct the $3 \times N$ matrices $\M E$ that consists
of the vectors $\{ \V e_i \}$ stacked up. Construct the $3 \times N$
matrices $\M F$ in a similar way from the vectors $\{ \V f_i \}$.
Compute the singular value decomposition svd($\M F \M E'$) =
$\M U' \M D \M V'$. Compute the rotation
matrix\footnotemark[1] $\M R = \M V \M U'$. The
translation estimate $\V t$ minimizes the sum of the square of
the distances $\lambda_i$ between the rotated points $\V a_i$
and corresponding line $(\V f_i, \V b_i)$.  Define matrix
$\M L = \sum_i (\M I - \V f_i \V f_i')'(\M I - \V f_i')$.
Define the vector $\V n = \sum_i (\M I -\V f_i \V f_i')' (\M I -
\V f_i \V f_i') (\M R \V a_i - \V b_i)$.  Then the translation is
$\V t = - \V L^{-1}\V n$.

\ \\
\noindent
{\bf Plane relative pose estimation}

Finally, if planes are the 3D features extracted for matching, then
the relative pose transformation can be estimated as follows.  Assume
$N$ paired planes.  The first set of planes is described by surface
normals $\{ \V e_i \}$ and a point on each plane $\{\V a_i\}$.  The
second set of planes is described by surface normals $\{ \V f_i\}$ and
a point on each plane $\{ \V b_i\}$.  Here we assume that the surface
normals always point outward from the surface. The points $\V a_i$ and
$\V b_i$ need not correspond to the same point after alignment.  The
desired rotation matrix $\M R$ minimizes $\sum_i \mid\mid \M R \V e_i
- \V f_i \mid\mid^2$. Construct the $3 \times N$ matrices $\M E$ that
consists of the vectors $\{ \V e_i \}$ stacked up.  Construct the $3
\times N$ matrices $\M F$ in a similar way from the vectors $\{ \V f_i
\}$. Compute the singular value decomposition svd($ \M F \M E'$) = $\M
U' \M D \M V'$~\cite{arun}. Compute the rotation
matrix\footnotemark[1] $\M R$ = $\M V \M U'$.  The translation
estimate ${\bf \it t}$ minimizes the sum of the square of the
distances $\lambda_i$ between the rotated point $\V a_i$ and the
corresponding plane $(\V f_i, \V b_i)$. Define matrix $\M L = \sum_i
\V f_i \V f_i'$.  Define the vector $\V n= \sum_i \V f_i \V f_i' (\M R
\V a_i - \V b_i)$. Then the translation is $\V t= - \M L^{-1}\V n$.

In all of the calculations described above, we assumed normally distributed
errors. For techniques to robustify these sorts of calculations, see
Zhang~\cite{zhang}.

\subsection{3D Applications \label{3dapp}}

This section links the techniques presented above to the robotics applications
of 3D localization of parts for
robot manipulation, self-localization of robot vehicles and
scene understanding for robot navigation.
The robotics tasks mentioned here are discussed in more detail
in other chapters in the series.
While this chapter focusses on robotics applications, there are
many other 3D sensing applications. An area of much current research is
that of acquiring 3D models, particularly for reverse engineering of
mechanical parts \cite{benko},
historical artifacts \cite{levoy},
buildings \cite{stamos} and
people for computer games and movies (see, {\it e.g.}, Cyberware's Whole Body X 3D Scanner).


The key tasks in robot manipulation are:
(1) identification of grasping points (see Chapters 27 and 28),
(2) identification of a collision free grasp (see Chapters 27 and 28),
(3) recognition of parts to be manipulated (see Chapter 23) and
(4) position estimation of parts for manipulation (see Chapters 23 and 42).

The key tasks in robot navigation and self-localization are:
(5) identification of a navigable groundplane (see Section \ref{ch31.3}),
(6) identification of a collision free path (see Chapter 35),
(7) identification of landmarks (see Chapter 36) and
(8) estimation of vehicle location (see Chapter 40).

The mobile and assembly robotics tasks link together rather
naturally.
Tasks 1 \& 5 have a connection, when we consider these tasks
in the context of unknown parts or paths. Part grasping requires
finding regions on a part that are graspable, which usually means locally
planar patches that are large enough that a gripper can make good contact
with them.
Similarly, navigation usually requires smooth ground regions that are
large enough for the vehicle - again locally planar patches.
Both tasks are commonly based on triangulated scene methods to
represent the data, from which connected regions of nearly coplanar
patches can be extracted.
The main difference between these two tasks is the groundplane
detection task is looking for a larger patch, that must be on the
``ground'' and upward facing.

Tasks 2 \& 6 require a method of representing empty space along the 
proposed trajectory of the gripper contacts or the vehicle.
The voxel representation is good for this task.

Tasks 3 \& 7 are model matching tasks and can use the methods of
Section \ref{match31} to match observed scene features to prestored
models of known parts or scene locations.
Commonly used features are large planar surfaces, 3D edges and 3D feature
points.

Tasks 4 \& 8 are pose estimation tasks and can use the methods of
Section \ref{pose23} to estimate the pose of the object 
relative to the sensor or vehicle ({\it i.e.} sensor) relative to the scene.
Again, commonly used features are large planar surfaces, 3D edges and 3D feature
points.


\section{Navigation and Terrain Classification  \label{ch31.3}}

One of the more compelling uses for range data is for navigation of
mobile robot vehicles.  Range data provides information about
obstacles and free space for the vehicle, in a direct geometric form.
Because of the realtime constraints of navigation, it is often
impractical to reconstruct a full 3D model of the terrain using the
techniques presented in this Chapter.  Instead, most systems use an
{\em elevation model}. \index{elevation model} An elevation model is a tesselated 2D
representation of space, where at each cell there is information about
the distribution of 3D points in the cell.  In its simplest
incarnation, the elevation map just contains the mean height of range
points above the nominal ground plane (Figure
\ref{elevation_map.ch31}).  This representation is sufficient for some
indoor and urban environments; more sophisticated versions that
determine a local plane, scatter of points in the cell, etc., are
useful for more complicated off-road driving.  Elevation maps marked
with obstacles have obvious utility for planning a collision-free path
for the vehicle.

\begin{figure}[hbt]
{\epsfxsize = 0.5\textwidth \epsfbox{BOOKFIGS/elevation_map.eps}}
\caption{Elevation map in urban terrain.  Each cell holds the height
of the terrain at that point.  More extensive features can also be
incorporated: slope, point variance, etc.
\label{elevation_map.ch31}}
\end{figure}


\subsection{Indoor Reconstruction}

SLAM algorithms (Chapter 37) using 2D laser rangefinders can
reconstruct floor plans with centimeter precision.  Some research has
extended this work to 3D reconstruction, using 2D lasers that are
swept along as the robot moves \cite{thrun00}.  The resultant point
cloud is typically registered using the pose of the robot as corrected
by the 2D SLAM algorithm, rather than any of the 3D registration
techniques covered in this chapter, because the laser is swept using
robot motion.

The raw points can be presented as a 3D image, or triangulated to give
a planar or mesh reconstruction of indoor surfaces. \index{indoor surfaces}
The latter is
especially compelling when camera images are texture-mapped onto the
surfaces, creating a realistic 3D model.  Figure
\ref{indoor_3d_map.ch31} shows some results from indoor mapping using
this technique (from \cite{thrun00}).  Smoothing of surface facets can
be used to recover planar surfaces \cite{liu01}.

\begin{figure}[hbt]
{\epsfxsize = 0.5\textwidth \epsfbox{BOOKFIGS/thrun-3d-indoor.eps}}
\caption{3D indoor map from a swept vertical plane LADAR.
Registration is from a horizontal LADAR using SLAM algorithms (from
\cite{thrun00}). 
\label{indoor_3d_map.ch31}}
\end{figure}



\subsection{Urban Navigation}

In urban navigation, the environment is structured, with roads,
buildings, sidewalks, and also moving objects - people and other
vehicles.  There are two main challenges: how to register laser scans
from a fast-moving vehicle for consistent mapping, and how to detect
moving objects using range scans (of course, other methods are also
used for detecting moving objects, e.g., appearance-based vision).

Outdoor vehicles can use precision GPS, inertial measurement units,
and wheel odometry to keep track of their position and orientation,
typically with an extended Kalman filter.  This method is good enough
to obviate the need for precise registration matching among scans, as
long as the motion model of the vehicle, and timing from the range
scanner, is used to place each scan reading in its proper position in
the world model.  This method also works in relatively easy off-road
terrain such as in the DARPA Grand Challenge
\cite{GrandChallenge}.  In all cases, the reduction of pose
estimation error is critical for good performance
\cite{thrun06}. 

Once scan readings are registered using the vehicle pose estimation,
they can be put into an elevation map, and obstacles detected using
the slope and vertical extent of the range readings in the cells of
the map.  A complication is that there may be multiple levels of
elevation in an urban setting, for example, an overpass would not be
an obstacle if it were high enough.  One proposal is to use multiple
elevation clusters within each cell; this technique is called a {\em
multi-level surface map \index{surface map}} (MLS, \cite{triebel06}).
Each cell in the map stores a set of surfaces represented by a mean
height and variance.  Figure \ref{elev_map.ch31} shows an MLS with a
cell size of $10 {\rm cm}^2$, with ground plane and obstacles marked.

\begin{figure}[hbt]
{\epsfxsize = 0.50\textwidth \epsfbox{BOOKFIGS/mls_map.eps}}
\caption{Elevation map of an urban scene, using 10cm x 10cm cells.
Obstacles in red, ground plane in green (from \cite{triebel06}).
\label{elev_map.ch31}}
\end{figure}

For dynamic objects, realtime stereo at 15 to 30 Hz can capture the
motion of the objects.  When the stereo rig is fixed, range background
subtraction isolates just the moving objects \cite{eveland98}.  When
the rig is on a moving vehicle, the problem is more difficult, since
the whole scene is moving with respect to the rig.  It can be solved
by estimating the motion of the rig with respect to the dominant rigid
background of the scene.  Let $R,t$ be the motion of the rig between
two frames, estimated by extracting features and matching them across
the two temporal frames, using the techniques of Chapter 37.
The homography $H(R,t)$ of Equation
\ref{homography.eq.ch31} provides a direct projection of the disparity
vectors $p_0 = [x_0,y_0,d_0,1]$ of the first frame to their
correspondences $H(R,t)p_0$ under $R,t$ in the second frame.  Using
the homography allows the points in the reference frame to be directly
projected onto the next frame, without translating to 3D points.
Figure \ref{ind_motion.ch31} shows the projected pixels under rigid
motion from a reference scene.  The difference between the projected
and actual pixels gives the independently moving objects (from
\cite{agrawal05}).

\begin{figure*}[ht!]
{\epsfxsize = 0.95\textwidth \epsfbox{BOOKFIGS/independent_motion.eps}}
\caption{Independent motion detection from a moving platform.
Reference image on left is forward-projected using the motion homography to
the center image; right image is difference with actual image.
\label{ind_motion.ch31}}
\end{figure*}


\subsection{Rough Terrain} \label{ch31.roughterrain}

Rough outdoor terrain presents to challenges:
\begin{itemize}
\item There may be no extensive ground plane to characterize
driveability and obstacles.
\item Vegetation that is pliable and driveable may appear as an
obstacle in range images.
\end{itemize}

Figure \ref{rough_terrain.ch31} shows a typical outdoor scene, with a
small (1 meter) robot driving through vegetation and rough ground
\cite{konolige06}.  Range data from stereo vision on the robot will
see the top of the vegetation and some ground points below.  The
elevation model can be extended to look at {\em point statistics}
within each cell, to capture the notion of a local ground plane and
penetrability related to vegetation.  In \cite{ollis06}, for
example, the set of proposed features includes:
\begin{itemize}
\item Major plane slope using a robust fit (Section
\ref{3d_feature_extraction.ch31}). 
\item Height difference of max and min heights.
\item Points above the major plane.
\item Density: ratio of points in the cell to rays that pass through
the cell.
\end{itemize}
The density feature is interesting (and expensive to compute), and
attempts to characterize vegetation such a grass or bushes, by looking
at whether range readings penetrate an elevation cell.  The idea of
using vegetation permeability to range readings has been discussed in
several other projects on off-road driving
\cite{manduchi03,lalonde05,kelly05}.  

\begin{figure}[hbt]
{\epsfxsize = 0.40\textwidth \epsfbox{BOOKFIGS/rough_terrain.eps}}
\caption{Rough terrain, no ground plane, driveable vegatation.
\label{rough_terrain.ch31}}
\end{figure}

Elevation map cells can be characterized as obstacles or driveable
through learning or hand-built classifiers.  Among the learning
techniques are neural nets \cite{ollis06} and Gaussian mixture
models with expectation-maximization learning \cite{vandapel06}.
The latter work also includes a lower level of interpretation,
classifying surfaces into planar patches (ground plane, solid
obstacles), linear features (telephone wires), and scattered features
(vegetation).  Figure \ref{point_classified.ch31} shows some results
from a laser-scanned outdoor scene.  Linear features such as telephone
wires and the telephone pole are accurately determined, as well as
vegetation with high penetrability.

\begin{figure}[hbt]
{\epsfxsize = 0.40\textwidth \epsfbox{BOOKFIGS/point_stats_classified.eps}}
\caption{Classification using point statistics, from
\cite{vandapel06}.  Red is planar surface, blue is thin linear
surface, green is scattered penetrable surface.
\label{point_classified.ch31}}
\end{figure}

Some additional problems occur in \index{rough-terrain navigation} rough-terrain navigation.  For
planar laser rangefinders that are swept over the terrain by vehicle
motion, the precision of vehicle pose estimation is important for
accurate reconstruction.  Attitude errors of less than $0.5^o$ can
cause false positives in obstacle detection, especially for sweeps far
ahead of the vehicle.  In \cite{thrun06}, this problem is solved by
looking at the time of each laser reading, and noting a correlation
between height errors and time difference in the readings.

Negative \index{obstacles} obstacles (ditches and cliffs) are difficult to detect with
range information, because the sensor may not see the bottom of the
obstacle.  This is especially true for vehicle-mounted sensors that
are not very high off the ground, and that are looking far ahead.
Negative obstacles can be infered when there is a gap in the ground
plane, and a plane slanted upwards at the back edge of the gap.  Such
artifacts can be efficiently found using column search on the
disparity image \cite{bellutta00}.

\section{Conclusions and Further Reading}

Range sensing is an active and expanding field of research in
robotics.  The presence of new types of devices - flash ladars,
multi-beam ladars, on-camera stereo processing - and the continuing
development of robust algorithms for object reconstruction,
localization and mapping has helped to bring applications out of the
laboratory and into the real world.  Indoor navigation with ladars is
already being exploited in commercial products (see, for example,
\cite{karto}).  As the basic capabilities become more robust,
researchers are looking to perform useful tasks, such as fetching
items or doing dishes \cite{STAIR}.

Another set of challenges are found in less benign
environments, such as urban and off-road driving (DARPA Grand
Challenge and Urban Challenge \cite{GrandChallenge}).  Stereo vision
and laser rangefinding also will play a role in helping to provide
autonomy for a new generation of more-capable robotic platforms that
rely on walking for locomotion \cite{cmu-humanoid}.  The challenges are
dealing with motion that is less smooth than wheeled platforms,
environments that contain dynamic obstacles, and task-oriented
recognition of objects.  




\bibliographystyle{latex8}
\begin{thebibliography}{99}

\bibitem{adan}
A. Adan, F. Molina, L. Morena, 
``Disordered patterns projection for 3D motion recovering'',
Proc. Int. Conf. on 
3D Data Processing, Visualization and Transmission, pp 262-269, Thessaloniki, 2004.

\bibitem{agrawal05}
M. Agrawal, K. Konolige, L. Iocchi,
``Real-time detection of independent motion using stereo'', 
IEEE workshop on Motion, 2005, Breckenridge, Colorado, pp 207 - 214.

\bibitem{alexa02computing}
M. Alexa, J. Behr, D. Cohen-Or, S. Fleishman, D. Levin,  C. T. Silva,
``Computing and Rendering Point Set Surfaces'',
IEEE Trans. on Vis. and Comp. Graph. 9(1):3-15, 2003

\bibitem{anderson}
D. Anderson, H. Herman, and A. Kelly,
``Experimental Characterization of Commercial Flash Ladar Devices'',
Int. Conf. of Sensing and Technology, Palmerston North, pp 17 - 23, November, 2005. 

\bibitem{arun}
K. S. Arun, T. S. Huang, S. D. Blostein,
``Least-Squares Fitting of Two 3-D Point Sets'', 
IEEE Trans. Pat. Anal. and Mach. Intel, 9(5), pp 698-700, 1987.

\bibitem{ayache}
N. Ayache,
{\underline {Artificial Vision for Mobile Robots:}}\\{\underline {Stereo Vision and Multi sensory Perception}},
MIT Press, Cambridge, 1991.

\bibitem{Badino_2011}
H. Badino, D. Huber, Y. Park, T. Kanade,
``Fast and Accurate Computation of Surface Normals from Range Images'',
Proc. ICRA, pp 3084-3091, Shanghai, China 2011,

\bibitem{Baribeau}
R. Baribeau, M. Rioux, and G. Godin, 
``Color Reflectance Modeling Using a Polychromatic Laser Range Sensor'',
IEEE Trans. Pat. Anal. and Mach. Intel, 14(2), pp. 263-269, February 1992.

\bibitem{barnard1982}
S. Barnard, M. Fischler,
``Computational stereo''.
ACM Computing Surveys, 14(4), pp 553-572, 1982.

\bibitem{Bauer:2008}
U.~Bauer and K.~Polthier.
``Detection of Planar Regions in Volume Data for Topology Optimization'',
Proc. 5th Int. Conf. on Advances in geometric modeling and processing
Hangzhou, China, 2008.

\bibitem{bellutta00}
P. Bellutta, R. Manduchi, L. Matthies, K. Owens, A. Rankin, 
``Terrain Perception for Demo III'', 
Proc. of the 2000 IEEE Intelligent Vehicles Conf., pp 326-331, Dearborn, 2000.

\bibitem{benko}
P. Benko, G. Kos, T. Varady, L. Andor, and R.R. Martin.
``Constrained fitting in reverse engineering''. 
Computer Aided Geometric Design, 19:173-205, 2002.

\bibitem{Bentley_1975}
J.~L. Bentley.
``Multidimensional binary search trees used for associative searching''.
Communications of the ACM, 18(9):509-517, 1975.

\bibitem{besl}
P. J. Besl,
{\underline{Analysis and Interpretation of Range}}\\{\underline {Images}},
Springer, Berlin-Heidelberg-New York, 1990.

\bibitem{besl2}
P. J. Besl, N. D. McKay,
``A method for registration of 3D shapes''
IEEE Trans. Pat. Anal and Mach. Intel., 14(2), pp 239-256, 1992.

\bibitem{blais}
F. Blais,
``Review of 20 years of range sensor development'',
J. of Electronic Imaging, 13(1), pp 231-240, Jan 2004.

\bibitem{Boehm_2007}
J.~B{\"o}hm and S.~Becker,
``Automatic marker-free registration of terrestrial laser scans using reflectance features'',
Proc. of 8th Conf. on Optical 3D Measurement
  Techniques, pp 338-344, Zurich, 2007.

\bibitem{bolles93}
R. Bolles, J. Woodfill, 
``Spatiotemporal consistency checking of passive range data'',  
Proc. Int. Symp. on Robotics Research, Hidden Valley, 1993.

\bibitem{Borrmann_2011}
D. Borrmann, J. Elseberg, A. N{\"u}chter, K. Lingemann,
``The 3D Hough Transform for Plane Detection in Point Clouds -- A Review and A new Accumulator Design'',
Journal of 3D Research, 2(2):1-13, 2011.

\bibitem{RAS2007}
D. Borrmann, J. Elseberg, K. Lingemann, A. N{\"u}chter, J. Hertzberg,
``Globally consistent 3d mapping with scan matching'',
J. Robotics and Autonomous Systems, 56(2):130142, 2008.

\bibitem{chen2}
Y. Chen, G. Medioni,
``Object modeling by registration of multiple range images'',
Image and Vision Comp., 10(3), pp. 145-155, 1992.

\bibitem{collins96}
R. T. Collins,
``A space-sweep approach to true multi-image matching'', 
Proc. Int. Conf. on Computer Vision and Pattern Recog, pp. 358-363, San Francisco, 1996.

\bibitem{criminisi}
A.  Criminisi, J. Shotton, A. Blake, C. Rother and P. H. S. Torr,
``Efficient Dense Stereo with Occlusions for New View Synthesis by Four State Dynamic Programming'', 
Int. J. of Computer Vision, 71(1), pp 89 - 110, 2007.

\bibitem{Curless}
B. Curless, M. Levoy,
``A Volumetric Method for Building Complex Models from Range Images'',
Proc.  of Int. Conf. on Comp. Graph. and Inter. Tech. (SIGGRAPH), pp 303 - 312, New Orleans, 1996.

\bibitem{GrandChallenge}
The DARPA Grand Challenge.
\verb+www.darpa.mil/grandchallenge05+, accessed Nov 12, 2007.

\bibitem{rgbdslam}
N. Engelhard, F. Endres, J. Hess, J. Sturm, W. Burgard,
``Real-time 3D visual SLAM with a hand-held camera'',
Proc. of the RGB-D Workshop on 3D Perception in Robotics at the
European Robotics Forum, 2011.

\bibitem{ISPRS2013}
J. Elseberg, D. Borrmann, A. N{\"u}chter,
``One Billion Points in the Cloud -- An Octree for Efficient Processing of 3D Laser Scans'',
ISPRS J. Photogrammetry and Remote Sensing, 2012.

\bibitem{eveland98}
C. Eveland, K. Konolige, R. Bolles,
``Background modeling for segmentation of video-rate stereo sequences'',
Proc. Int. Conf. on Computer Vision and Pattern Recog, pp 266-271, Santa Barbara, 1998.

\bibitem{faugeras96}
O. Faugeras, B. Hotz, H. Mathieu, T. Vi\'eville, Z. Zhang, P. Fua,
E. Th\'eron, L. Moll, G. Berry, J. Vuillemin, P. Bertin and C. Proy,
``Real time correlation based stereo: algorithm implementations and applications'',
International Journal of Computer Vision, 1996.

\bibitem{ransac}
M. A. Fischler, R. C. Bolles,
``Random sample consensus: a paradigm for model fitting with applications to
image analysis and automated cartography'',
Comm. of the ACM, 24(6), pp. 381-395, June 1981. 

\bibitem{naidu}
R. B. Fisher, D. K. Naidu,  
``A Comparison of Algorithms for Subpixel Peak Detection'',
in Sanz (ed.) {\underline {Image Technology}},
Springer-Verlag, Heidelberg, 1996.

\bibitem{awf}
A. W. Fitzgibbon,
``Simultaneous Linear Estimation of Multiple View Geometry and Lens Distortion'',
Proc. Int. Conf. on Computer Vision and Pattern Recog, Vol I, pp 125-132, Kauai, Hawaii, 2001.

\bibitem{focusrobotics}
Focus Robotics Inc.,
\verb+www.focusrobotics.com+, accessed Nv 12, 2007.

\bibitem{foley}
J. D. Foley, A. van Dam, S. K. Feiner, J. F. Hughes,
{\underline{Computer Graphics: principles and practice}} (second edition in C),
Addison Wesley, Boston et al, 1996.

\bibitem{Friedman_1977}
J.~H. Friedman, J.~L. Bentley, and R.~A. Finkel,
``An algorithm for finding best matches in logarithmic expected time''.
ACM Trans. on Math. Software, 3(3):209-226, 1977.

\bibitem{fua93}
P. Fua,
``A parallel stereo algorithm that produces dense depth maps and preserves image features'',
Machine Vision and Applications 6(1), pp. 35-49, 1993.

\bibitem{garland97surface}
M. Garland, P. Heckbert,
``Surface Simplification Using Quadric Error Metrics'',
Proc. of SIGGRAPH 97, 1997.

\bibitem{Greenspan_2003}
M.~Greenspan and M.~Yurick,
``Approximate K-D Tree Search for Efficient ICP'',
Proc. 4th IEEE Int. Conf. on Recent Advances in 3D Digital Imaging and Modeling,
pp. 442-448, Banff, Canada, 2003.

\bibitem{grimson}
E. Grimson,
{\underline {Object Recognition by Computer:}}\\{\underline {The role of geometric constraints}},
MIT Press, London, 1990.

\bibitem{haehnel02}
D. Haehnel, W. Burgard,
``Probabilistic Matching for 3D Scan Registration'',
Proc. of the VDI-Conference Robotik 2002 (Robotik), Ludwigsburg, 2002.

\bibitem{haehnel02b}
D. Haehnel, D. Schulz, W. Burgard,
``Mapping with mobile robots in populated environments'',
in Proc. of the IEEE/RSJ Int. Conf. on Intelligent
Robots and Systems (IROS), Vol 1, pp 496- 501, Lausanne, 2002.

\bibitem{ollis06}
M. Happold, M. Ollis, N. Johnson,
``Enhancing Supervised Terrain Classification with Predictive Unsupervised Learning'',
Robotics: Science and Systems, Philadelphia, 2006.

\bibitem{hartley}
R. Hartley, A. Zisserman.
{\underline{Multiple view geometry}}\\{\underline{in computer vision}}.
Cambridge ; New York : Cambridge University Press, 2000.

\bibitem{Hertzmann}
A. Hertzmann, S. M. Seitz, 
``Example-Based Photometric Stereo: Shape Reconstruction with General, Varying BRDFs'',
IEEE Trans. Pat. Anal. and Mach. Intel., 27(8), pp. 1254-1264, August 2005.

\bibitem{hilton2}
A. Hilton, A. Stoddart, J. Illingworth, T. Windeatt.
``Implicit surface-based geometric fusion'',
Comp. Vis. and Image Under., 69(3), pp 273-291, March 1998.

\bibitem{hoover}
A. Hoover, G. Jean-Baptiste, X. Jiang, P. J. Flynn,
H. Bunke, D. Goldgof, K. Bowyer,
D. Eggert, A. Fitzgibbon, R. Fisher.
``An Experimental Comparison of Range Segmentation Algorithms'',
IEEE Trans. Pat. Anal. and Mach. Intel., 18(7), pp 673--689, July 1996.

\bibitem{hoppe}
H. Hoppe, T. DeRose, T. Duchamp, J. McDonald, W. Stuetzle,
``Surface reconstruction from unorganized points'',
Comp. Graphics, 26(2), pp 71-78, 1992.

\bibitem{hoppe2}
H. Hoppe,	
``New quadric metric for simplifying meshes with appearance attributes'',
IEEE Visualization 1999 Conference, pp 59-66, San Francisco, October, 1999.

\bibitem{Horn_1987}
B.~K.~P. Horn,
``Closed--form solution of absolute orientation using unit quaternions'',
J. OSA A, 4(4):629-642, 1987.

\bibitem{Horn_1988}
B.~K.~P. Horn, H.~M. Hilden, and Sh. Negahdaripour.
``Closed--form solution of absolute orientation using orthonormal matrices''.
J. OSA A, 5(7):1127-1135, 1988.

\bibitem{Hornung_2013}
A. Hornung, K.M. Wurm, M. Bennewitz, C. Stachniss, and W. Burgard,
``OctoMap: An Efficient Probabilistic 3D Mapping Framework Based on Octrees''
Autonomous Robots, 2013.

\bibitem{Hough:1962}
P.~V.~C. Hough,
``Method and Means for Recognizing Complex Patterns'',
US Patent 3069654, 1962.

\bibitem{HuberPhD}
D. Huber,
``Automatic Three-dimensional Modeling from Reality'',
PHD thesis, Robotics Institute, Carnegie Mellon University, 2002.

\bibitem{Hyafil_1977}
L.~Hyafil and R.~L. Rivest,
''Constructing optimal binary decision trees is np-complete'',
Inf. Proc. Letters 5, pp 15-17, May 1976.

\bibitem{kinectfusion}
S. Izadi, D. Kim, O. Hilliges, D. Molyneaux, R. Newcombe, P. Kohli,
J. Shotton, S. Hodges, D. Freeman, A. Davison, A. Fitzgibbon,
``KinectFusion: Real-time 3D Reconstruction and Interaction Using a Moving Depth Camera'',
ACM Symp. on User Interface Software and Technology, October 2011.

\bibitem{karto}
KARTO: Software for robots on the move.
\verb+www.kartorobotics.com+, accessed Nov 12, 2007.


\bibitem{kelly03}
A. Kelly, R. Unnikrishnan,
``Efficient Construction of Globally Consistent Ladar Maps using Pose Network Topology
and Nonlinear Programming'',
Proc. Int. Symp of Robotics Research, Siena, I2003.

\bibitem{kelly05}
A. Kelly, A. Stentz, O. Amidi, M. Bode, D. Bradley, A. Diaz-Calderon, M. Happold, H. Herman, R. Mandelbaum,
T. Pilarski, P. Rander, S. Thayer, N. Vallidis, R. Warner,
``Toward Reliable Off Road Autonomous Vehicles Operating in Challenging Environments'',
Int. J. of Robotics Research, Vol. 25, No. 5-6, 449-483, 2006.

\bibitem{koninckx}
T. P. Koninckx, L. J. Van Gool,
``Real-Time Range Acquisition by Adaptive Structured Light'',
IEEE Trans Pat. Anal. and Mach. Intel. 28(3), pp. 432-445, March 2006. 

\bibitem{konolige97}
K. Konolige,
``Small vision system. hardware and implementation'',
in Proc. Int. Symp. on Robotics Research, pages 111--116,
Hayama, Japan, 1997.

\bibitem{konolige99}
K. Konolige, K. Chou,
``Markov localization using correlation'',
Proc. Int. Joint Conf. on AI (IJCAI), pp 1154 - 1159, Stockholm, 1999.

\bibitem{konolige04}
K. Konolige,
``Large-scale map-making'',
Proceedings of the National Conference on AI (AAAI), pp. 457 - 463, San Jose, CA, 2004.

\bibitem{konolige06}
K. Konolige, M. Agrawal, R. C. Bolles, C. Cowan, M. Fischler, B. Gerkey,
``Outdoor mapping and Navigation using Stereo Vision'',
Intl. Symp. on Experimental Robotics (ISER), Rio de Janeiro, 2006.

\bibitem{Lakaemper:2006}
R.~Lakaemper and L.~J. Latecki,
``Extended EM for Planar Approximation of 3D Data'',
Proc. IEEE ICRA, 2006.

\bibitem{lalonde05}
J.-F. Lalonde, N. Vandapel, M. Hebert,
``Data Structure for Efficient Processing in 3-D'',
Robotics: Science and Systems 1, Cambridge, 2005.

\bibitem{vandapel06}
J. Lalonde, N. Vandapel, D. Huber, M. Hebert,
``Natural terrain classification using three-dimensional ladar data
for ground robot mobility'',
J. of Field Robotics, Vol. 23, No. 10 (2006).

\bibitem{LeMoigne}
J. J. LeMoigne, A. M. Waxman, 
``Structured Light Patterns for Robot Mobility'',
Robotics and Automation Vol 4, pp. 541-548, 1988.

\bibitem{levoy}
M. Levoy, K. Pulli, B. Curless, S. Rusinkiewicz, D. Koller, L. Pereira, M. Ginzton, S. Anderson, J. Davis, J. Ginsberg, J. Shade, D. Fulk.
``The Digital Michelangelo Project: 3D Scanning of Large Statues '',
Proc. 27th Conf. on Computer graphics and interactive techniques
(SIGGRAPH), pp 131 - 144, New Orleans, July 2000.

\bibitem{little}
J. Little, S. Se, D. Lowe,
``Vision based mobile robot localization and mapping using scale-invariant features",
Proc. IEEE Inf. Conf. on Robotics and Automation, pp 2051-2058, Seoul, 2001.

\bibitem{liu01}
Y. Liu, R. Emery, D. Chakrabarti, W. Burgard, S. Thrun, 
``Using EM to Learn 3D Models of Indoor Environments with Mobile
Robots'', 
Proc.Int. Conf. on Machine Learning, pp. 329-336, Williamstown, 2001.

\bibitem{Lobay}
A. Lobay, D. A. Forsyth, 
``Shape from Texture without Boundaries'',
Int. J. Comp. Vision, 67(1), pp. 71-91, April 2006.

\bibitem{lowe}
D. Lowe, 
``Distinctive image features from scale-invariant keypoints'',
Int. J. Comp. Vis, 2(60), pp 91-110, 2004.

\bibitem{lorensen87marching}
W. E. Lorensen, H. E. Cline,
``Marching Cubes: A high resolution 3D surface construction algorithm'',
Computer Graphics, 21(4), 163-169, 1987.

\bibitem{lu97}
F. Lu, E. Milios,
``Globally consistent range scan alignment for environment mapping'',
Autonomous Robots, Vol 4, pp 333-349 (1997).

\bibitem{manduchi03}
R. Manduchi, A. Castano, A. Talukder, L.Matthies,
``Obstacle Detection and Terrain Classification for Autonomous Off-Road Navigation'',
Autonomous Robots, Vol 18, pp 81-102, 2005.

\bibitem{matthies93}
L. Matthies,
``Stereo vision for planetary rovers: stochastic
modeling to near realtime implementation'',
Int. J. Comp. Vis,  8(1), pp. 71-91, 1993.

\bibitem{melax98simple}
S. Melax,
``A Simple, Fast and Effective Polygon Reduction Algorithm'',
GameDeveloper, November, 1998

\bibitem{Mitra_2003}
N.~J. Mitra, An Nguyen,
``Estimating surface normals in noisy point cloud data'',
Proc. SCG, pp 322-328, New York, USA, 2003.
  
\bibitem{Mitra_2004}
N.~J. Mitra, N. Gelfand, H. Pottmann, L. Guibas. 
``Registration of point cloud data from a geometric optimization perspective'',
Proc. Eurographics/ACM SIGGRAPH Symp. on Geometry processing, pp 22-31,
Nice, France, 2004.

\bibitem{moravec79}
H. Moravec, 
``Visual mapping by a robot rover'',
Proc. Int. Joint Conf. on AI (IJCAI), Tokyo, pp. 598-600, 1979.

\bibitem{nayar}
S. K. Nayar, Y. Nakagawa, 
``Shape from Focus'',
IEEE Trans Pat. Anal. and Mach. Intel. 16(8), pp. 824-831, August 1994.

\bibitem{CVIU2010}
A. N{\"u}chter, J. Elseberg, P. Schneider, D. Paulus,
``Study of Parameterizations for the Rigid Body Transformations of The Scan Registration Problem'',
J. CVIU, 114(8):963-980, 2010

\bibitem{3DIM_2007}
A. N{\"u}chter, K. Lingemann, J. Hertzberg,
``Cached $k$-d tree search for ICP Algorithms'',
Proc. 6th IEEE Int. Conf. on Recent Advances in 3D Digital Imaging and Modeling,
pp 419-426, Montreal, Canada, 2007

\bibitem{okutomi93}
M. Okutomi, T. Kanade,
``A multiple-baseline stereo'',
IEEE Trans Pat. Anal. and Mach. Intel., 15(4), pp. 353-363, 1993.

\bibitem{ollis}
M. Ollis, T. Williamson,
``The Future of 3D Video'', Computer, 34(6), pp. 97-99, June 2001.

\bibitem{cmu-humanoid}
Perception for Humanoid Robots.
\verb+www.ri.cmu.edu/projects/project_595.html+, accessed Nov 12, 2007.

\bibitem{pointclouds.org}
Point Cloud Library (PCL),
\verb+pointclouds.org+, accessed Jan 17, 2013.

\bibitem{ptgrey}
Point Grey Research Inc.,
\verb+www.ptgrey.com+, accessed Nov 12, 2007.

\bibitem{pollefeys}
M. Pollefeys, R. Koch, L. Van Gool,
``Self-Calibration and Metric Reconstruction Inspite of Varying and Unknown Intrinsic Camera Parameters'',
Int. J. of Computer Vision, 32(1), pp 7-25, 1999.

\bibitem{Rusi_2001}
S.~Rusinkiewicz and M.~Levoy.
``Efficient variants of the {ICP} algorithm'',
Proc. of the 3rd Int. Conf. on 3D Digital Imaging and Modellling, pp 145-152,
Quebec City, 2001.

\bibitem{RaduPhD}
R. B. Rusu,
``Semantic 3D Object Maps for Everyday Manipulation in Human Living Environments'',
PhD Thesis, TU Munich, 2009.

\bibitem{scharstein02taxonomy}
D. Scharstein, R. Szeliski, R. Zabih,
``A taxonomy and evaluation of dense two-frame stereo correspondence algorithms'',
Int. Journal of Computer Vision, 47(1/2/3), pp 7-42, April-June 2002.

\bibitem{middlebury}
D. Scharstein, R. Szeliski,
``Middlebury College Stereo Vision Research Page'',
\verb+vision.middlebury.edu/stereo+, accessed Nov 12, 2007.

\bibitem{Schnabel:2007}
R.~Schnabel, R.~Wahl, and R.~Klein,
``Efficient RANSAC for Point-Cloud Shape Detection'',
Computer Graphics Forum, 2007.

\bibitem{Schroeder}
W. J. Schroeder, J. A. Zarge, W. E. Lorensen,
``Decimation of triangle meshes''
Proc.  of Int. Conf. on Comp. Graph. and Inter. Tech. (SIGGRAPH), pp 65 - 70, Chicago, 1992.

\bibitem{STAIR}
The Stanford Artificial Intelligence Robot.
\verb+www.cs.stanford.edu/group/stair+, accessed Nov 12, 2007.

\bibitem{stamos}
I. Stamos and P. Allen.
``3-D Model Construction Using Range and Image Data''
Proc. IEEE Conf. on Computer Vision and Pattern Recognition, 
Volume: 1,  pp 531-536, Hilton Head Island, 2000. 

\bibitem{stettner}
R. Stettner, H. Bailey, and S. Silverman,
``Three-Dimensional Flash Ladar Focal Planes and Time-Dependent Imaging'',
Advanced Scientific Concepts, 2006;
Technical report at URL (February 23, 2007):
\verb+www.advancedscientificconcepts.com/+\\
\verb+images/Three%20Dimensional%20Flash%20Ladar+\\
\verb+%20Focal%20Planes-ISSSR%20Paper.pdf+, accessed Nov 12, 2007.

\bibitem{thrun00}
S. Thrun, W. Burgard, D. Fox,
``A real-time algorithm for mobile robot mapping with applications to
multi-robot and 3D mapping'',  
Proc. IEEE Inf. Conf. on Robotics and Automation, pp 321-328, San Francisco, 2000.

\bibitem{thrun}
S. Thrun, 
``A probabilistic online mapping algorithm for teams of mobile robots'',
Int. J. of Robotics Research, 20(5), pp 335-363, 2001.

\bibitem{thrun05}
S. Thrun, W. Burgard, and D. Fox. 
{\em Probabilistic Robotics}, MIT Press, Cambridge, MA, 2005.

\bibitem{thrun06}
S. Thrun, M. Montemerlo, H. Dahlkamp, et al.,
``Stanley: The Robot That Won The DARPA Grand Challenge'',
Journal of Field Robotics, Vol. 23, No. 9, 2006.

\bibitem{triebel06}
R. Triebel, P. Pfaff, W. Burgard,
``Multi-level surface maps for outdoor terrain mapping and loop closing'',
Proc. of the IEEE Int. Conf. on Intel. Robots and Systems (IROS), Beijing, 2006.

\bibitem{turk}
G. Turk, M. Levoy,
``Zippered Polygon Meshes from Range Images'',
Proc.  of Int. Conf. on Comp. Graph. and Inter. Tech. (SIGGRAPH), pp 311-318, Orlando, 1994.

\bibitem{tyzx}
TYZX Inc.,
\verb+www.tyzx.com+, accessed Nov 12, 2007.

\bibitem{videre}
Videre Design LLC,
\verb+www.videredesign.com+, accessed Nov 12, 2007.

\bibitem{Walker_1991}
M.~W. Walker, L.~Shao, and R.~A. Volz,
``Estimating 3-d location parameters using dual number quaternions'',
CVGIP: Image Understanding, 54:358-367, 1991.

\bibitem{Wulf:2004}
O.~Wulf, K.~O. Arras, H.~I. Christensen, and B.~A. Wagner,
``{2D} {M}apping of {C}luttered {I}ndoor {E}nvironments by {M}eans of
  {3D} {P}erception'',
Proc. ICRA, pp 4204-4209, New Orleans, USA, 2004.

\bibitem{yang03multiresolution}
R. Yang and M. Pollefeys,
``Multi-resolution real-time stereo on commodity graphics hardware'',
Int. Conf. Comp. Vis and Pat. Rec, Vol 1, pp 211-217, Madison, 2003.

\bibitem{Yu:2008}
G.~Yu, M.~Grossberg, G.~Wolberg, and I.~Stamos,
``Think Globally, Cluster Locally:A Unified Framework for Range Segmentation'',
Proc. 4th Int. Symp. on 3DPVT, Atlanta, USA, 2008.

\bibitem{zabih94}
R. Zabih,  J. Woodfill,
``Non-parametric local transforms for computing visual correspondence'',
Proc. Eur. Conf. on Comp. Vis, Vol 2, pp 151-158 Stockholm, 1994.

\bibitem{zach03accurate}
C. Zach, A. Klaus, M. Hadwiger, K. Karner,
``Accurate dense stereo reconstruction using graphics hardware'',
Proc. EUROGRAPHICS, pp 227-234, Granada, 2003.

\bibitem{zhang}
Z. Zhang,
``Parameter estimation techniques: a tutorial with application to conic fitting'',
Image and Vision Comp., Vol 15, pp 59-76, 1997.

\bibitem{zhang2}
Z. Zhang,
``Iterative point matching for registration of free--form curves''.
Technical Report RR-1658, INRIA--Sophia Antipolis, Valbonne Cedex, France,
1992.

\end{thebibliography}

\end{document}
